#!/usr/bin/env python3

# jsrunner jsfile [cfile] will create a C file that executes the given
#   JavaScript file in JerryScript, by converting it to a C string in source.

import argparse
import os
import shutil
import subprocess
import sys

def jprint(arg):
    print('jsrunner: %s' % arg)

def create_cstring_declaration(varname, rawstring, initialIndent=0, indent=4):
    # requires: varname is the C variable name to be used for the string
    #             declaration; rawstring is the Unicode string contents;
    #             initialIndent is the indent for the first line; indent is
    #             the indent for additional lines
    #  effects: returns a string defining rawstring as varname in C code
    #  example: for varname 'code' and rawstring 'print("Hello");', returns
    #             something like "char code[] = "print(\"Hello\");\n" that
    #             will compile as valid C and yield the given rawstring
    output = '%schar %s[] =\n' % (' ' * initialIndent, varname)
    last = None;
    maxline = 74 - indent
    for line in rawstring.split('\n'):
        first = True
        while line:
            part = line[:maxline]
            line = line[maxline:]

            # replace backslash with double backslash
            part = part.replace('\\', '\\\\')

            # replace quote with backslash quote
            part = part.replace('"', '\\"')

            if last is not None:
                output += '    "%s%s"\n' % (last, '\\n' if first else '')
            last = part
            first = False

    if last is None:
        last = ''
    output += '    "%s";\n' % last
    return output

if __name__ == "__main__":
    # parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-b', metavar='BOARDNAME', default='arduino_101',
                        help='override board name (default: arduino_101)')
    parser.add_argument('-s', action='store_true',
                        help='skip building and flashing')
    parser.add_argument('-f', action='store_true',
                        help='disable prompt to overwrite existing output file')
    parser.add_argument('-v', metavar='VARNAME', default='script',
                        help='override string variable name (default: script)')
    parser.add_argument('jsfile', help='JavaScript input file')
    parser.add_argument('outfile', help='override output filename '
                        '(default: script.h)', nargs='?')
    args = parser.parse_args()

    outfile = 'script.h'
    if args.outfile:
        outfile = args.outfile

    if not os.path.isfile(args.jsfile):
        jprint("error: jsfile argument '%s' must specify a JavaScript file" %
               args.jsfile)
        sys.exit(1)

    try:
        BASEDIR = os.environ['ZJS_BASE']
    except KeyError:
        jprint("error: ZJS_BASE not set, source the zjs-env.sh file!")
        system.exit(1)

    # create build dir template
    BUILDDIR = os.path.join(BASEDIR, 'build')
    if os.path.exists(BUILDDIR):
        print("Removing old build directory...", end='')
        sys.stdout.flush()
        shutil.rmtree(BUILDDIR)
        print(" done.")
    print("Creating build directory from template...", end='')
    sys.stdout.flush()
    shutil.copytree(os.path.join(BASEDIR, 'scripts/template'), BUILDDIR)
    print(" done.")

    # environment variable ZJS_MINIFIER can specify a JavaScript minifier
    # On Ubuntu:
    #   $ apt-get install yui-compressor
    # gives you or 'yui-compressor', or
    #   $ apt-get install node-uglify
    # gives you 'uglifyjs'
    minifier = os.environ.get('ZJS_MINIFIER')
    if not minifier:
        minifier = 'yui-compressor'

    try:
        output = subprocess.check_output([minifier, args.jsfile])
        minjs = output.decode('utf-8')
    except FileNotFoundError:
        jprint("warning: minifier '%s' not found" % minifier)
        print("Install yui-compressor or set ZJS_MINIFIER to specify a "
              "command-line JavaScript\nminifier!")
        with open(args.jsfile, 'r') as f:
            minjs = f.read()

    outpath = os.path.join(BUILDDIR, outfile)
    if os.path.exists(outpath) and not args.f:
        jprint("warning: output file '%s' already exists" % outfile)
        if not input("Overwrite (y/n)? ").lower() == 'y':
            sys.exit(1)

    print("Writing %s..." % outfile, end='')
    sys.stdout.flush()

    with open(outpath, 'w') as f:
        f.write('// Copyright (c) 2016, Intel Corporation.\n')
        f.write('// generated by jsrunner\n\n')

        cstr = create_cstring_declaration(args.v, minjs)
        f.write('%s\n' % cstr)

    print(" done.")

    if args.s:
        sys.exit(0)

    os.chdir(BUILDDIR)
    print("Building OS image...\n");
    board = 'BOARD=%s' % args.b
    subprocess.call(['make', board])

    print("Flashing OS image...");
    subprocess.call(['make', board, 'flash'])
